/*
 * SPDX-FileCopyrightText: Copyright (c) 2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: LicenseRef-NvidiaProprietary
 *
 * NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
 * property and proprietary rights in and to this material, related
 * documentation and any modifications thereto. Any use, reproduction,
 * disclosure or distribution of this material and related documentation
 * without an express license agreement from NVIDIA CORPORATION or
 * its affiliates is strictly prohibited.
 */

// src/build.rs
// Registry build script. This takes the YAML registry schema files
// from the databases/ directory, and uses them to generate the
// src/registries.rs file, which will now contain ALL compile-time
// embedded registries for use by any components which need to
// work with mlxconfig variable management and assignment.

use std::fs;
use std::path::Path;
use std::sync::LazyLock;

// Of course, pull in the mlxconfig_variables crate
// so we can deserialize the registry YAML files,
// build variables, and generate corresponding .rs.
use mlxconfig_variables::{MlxConfigVariable, MlxVariableRegistry, MlxVariableSpec};

static DEBUG_BUILD_SCRIPT: LazyLock<bool> = LazyLock::new(|| {
    // Note that this variable is only evaluated when the build script is run,
    // but the build script output (which this controls) is persisted for later
    // `cargo` commands.
    matches!(std::env::var("DEBUG_MLXCONFIG"), Ok(value) if value != "0")
});

fn main() {
    println!("cargo:rerun-if-changed=databases/");

    let registries = load_registries();
    let generated_code = generate_registries_code(&registries);
    write_generated_code(&generated_code);

    if *DEBUG_BUILD_SCRIPT {
        println!(
            "cargo:warning=Generated {} registries with {} total variables",
            registries.len(),
            registries.iter().map(|r| r.variables.len()).sum::<usize>()
        );
    }
}

// load_registries loads and validates all registry
// YAML files from the databases/ directory.
fn load_registries() -> Vec<MlxVariableRegistry> {
    let databases_dir = Path::new("databases");
    if !databases_dir.exists() {
        panic!("databases/ directory not found!");
    }

    let mut registries = Vec::new();

    // Process all .yaml files in databases/
    for entry in fs::read_dir(databases_dir).expect("Failed to read databases directory") {
        let entry = entry.expect("Failed to read directory entry");
        let path = entry.path();

        if path.extension().and_then(|s| s.to_str()) != Some("yaml") {
            continue;
        }

        let file_name = path
            .file_stem()
            .and_then(|s| s.to_str())
            .expect("Invalid filename");

        println!("cargo:rerun-if-changed={}", path.display());

        let registry = load_registry_file(&path, file_name);
        registries.push(registry);
    }

    if registries.is_empty() {
        panic!("No YAML files found in databases/ directory!");
    }

    // Sort by registry name for consistent output.
    registries.sort_by(|a, b| a.name.cmp(&b.name));
    registries
}

// load_registry_file loads and validates a single registry
// file discovered in the databases/ directory.
fn load_registry_file(path: &Path, file_name: &str) -> MlxVariableRegistry {
    let yaml_content = fs::read_to_string(path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {}", path.display(), e));

    let registry: MlxVariableRegistry = serde_yaml::from_str(&yaml_content).unwrap_or_else(|e| {
        panic!(
            "Failed to parse {} as MlxVariableRegistry: {}",
            path.display(),
            e
        )
    });

    if *DEBUG_BUILD_SCRIPT {
        println!(
            "cargo:warning=[INFO] Parsed registry '{}' with {} variables from {}",
            registry.name,
            registry.variables.len(),
            file_name
        );

        // Show filter info during build.
        if registry.has_filters() {
            println!(
                "cargo:warning=[INFO]   Filters: {}",
                registry.filter_summary()
            );
        } else {
            println!("cargo:warning=[INFO]   No device filters configured for this registry");
        }
    }

    registry
}

// generate_registries_code generates the complete registries.rs
// Rust code file for all registries parsed from the databases/
// directory.
fn generate_registries_code(registries: &[MlxVariableRegistry]) -> String {
    let mut code = String::new();

    // First, dump out the header for registries.rs.
    code.push_str("// This file was auto-generated by build.rs\n");
    code.push_str("use once_cell::sync::Lazy;\n\n");
    code.push_str(
        "pub static REGISTRIES: Lazy<Vec<mlxconfig_variables::MlxVariableRegistry>> = Lazy::new(|| {\n    vec![\n",
    );

    // Now generate the code for each registry.
    for registry in registries {
        code.push_str(&generate_registry_code(registry));
    }

    // And finally, dump out the accessor functions
    // for working with the defined registries.
    code.push_str("]\n});\n\n");
    code.push_str(&generate_accessor_functions());
    code
}

// generate_registry_code generates code for a
// single registry to put into registries.rs,
// taking whitespace and such into consideration
// so it looks pretty when you actually read the
// code itself.
fn generate_registry_code(registry: &MlxVariableRegistry) -> String {
    let mut code = String::new();

    code.push_str(&format!(
        "        mlxconfig_variables::MlxVariableRegistry::new({:?})\n",
        registry.name
    ));

    // Generate filters if they exist.
    if registry.has_filters() {
        code.push_str(&generate_filters_code(registry.filters.as_ref().unwrap()));
    }

    code.push_str("            .variables(vec![\n");

    // And now generate all variables for the registry.
    for variable in &registry.variables {
        code.push_str(&generate_variable_code(variable));
        code.push('\n');
    }

    code.push_str("            ]),\n");
    code
}

// generate_filters_code generates code for
// any configured registry device filters.
fn generate_filters_code(filter_set: &mlxconfig_device::filters::DeviceFilterSet) -> String {
    let mut code = String::new();

    code.push_str("            .with_filters(\n");
    code.push_str("                mlxconfig_device::filters::DeviceFilterSet::new()");

    // Generate code for each filter in the set.
    for filter in &filter_set.filters {
        code.push_str("\n                    .with_filter(");
        code.push_str(&generate_single_filter_code(filter));
        code.push(')');
    }

    code.push_str("\n            )\n");
    code
}

// generate_single_filter_code generates code for a single device filter.
fn generate_single_filter_code(filter: &mlxconfig_device::filters::DeviceFilter) -> String {
    let field_code = match filter.field {
        mlxconfig_device::filters::DeviceField::DeviceType => {
            "mlxconfig_device::filters::DeviceField::DeviceType"
        }
        mlxconfig_device::filters::DeviceField::PartNumber => {
            "mlxconfig_device::filters::DeviceField::PartNumber"
        }
        mlxconfig_device::filters::DeviceField::FirmwareVersion => {
            "mlxconfig_device::filters::DeviceField::FirmwareVersion"
        }
        mlxconfig_device::filters::DeviceField::MacAddress => {
            "mlxconfig_device::filters::DeviceField::MacAddress"
        }
        mlxconfig_device::filters::DeviceField::Description => {
            "mlxconfig_device::filters::DeviceField::Description"
        }
        mlxconfig_device::filters::DeviceField::PciName => {
            "mlxconfig_device::filters::DeviceField::PciName"
        }
        mlxconfig_device::filters::DeviceField::Status => {
            "mlxconfig_device::filters::DeviceField::Status"
        }
    };

    let values_code = format!(
        "vec![{}]",
        filter
            .values
            .iter()
            .map(|v| format!("{v:?}.to_string()"))
            .collect::<Vec<_>>()
            .join(", ")
    );

    let match_mode_code = match filter.match_mode {
        mlxconfig_device::filters::MatchMode::Regex => {
            "mlxconfig_device::filters::MatchMode::Regex"
        }
        mlxconfig_device::filters::MatchMode::Exact => {
            "mlxconfig_device::filters::MatchMode::Exact"
        }
        mlxconfig_device::filters::MatchMode::Prefix => {
            "mlxconfig_device::filters::MatchMode::Prefix"
        }
    };

    format!(
        "mlxconfig_device::filters::DeviceFilter::new({field_code}, {values_code}, {match_mode_code})",
    )
}

// generate_variable_code generates code for a single
// variable in the registry, with MlxVariableSpec code
// generation coming at the tail end.
fn generate_variable_code(variable: &MlxConfigVariable) -> String {
    format!(
        r#"                mlxconfig_variables::MlxConfigVariable::builder()
                    .name({:?}.to_string())
                    .description({:?}.to_string())
                    .read_only({})
                    .spec({})
                    .build(),"#,
        variable.name,
        variable.description,
        variable.read_only,
        generate_spec_code(&variable.spec)
    )
}

// generate_accessor_functions generates the accessor functions
// for actually working with the REGISTRIES constant.
fn generate_accessor_functions() -> String {
    r#"/// get_all returns all hardware configuration registries.
pub fn get_all() -> &'static [mlxconfig_variables::MlxVariableRegistry] {
    &REGISTRIES
}

/// get will return a registry by name.
pub fn get(name: &str) -> Option<&'static mlxconfig_variables::MlxVariableRegistry> {
    REGISTRIES.iter().find(|r| r.name == name)
}

/// list will return a list of all registry names.
pub fn list() -> Vec<&'static str> {
    REGISTRIES.iter().map(|r| r.name.as_str()).collect()
}

/// get_registries_for_device returns all registries that match the given device.
/// If a registry has no filters configured, it matches all devices.
pub fn get_registries_for_device(
    device_info: &mlxconfig_device::info::MlxDeviceInfo,
) -> Vec<&'static mlxconfig_variables::MlxVariableRegistry> {
    REGISTRIES
        .iter()
        .filter(|r| r.matches_device(device_info))
        .collect()
}
"#
    .to_string()
}

// write_generated_code writes the generated code to the
// output registries.rs file.
fn write_generated_code(code: &str) {
    let src_dir = Path::new("src");
    if !src_dir.exists() {
        fs::create_dir_all(src_dir).expect("Failed to create src directory");
    }

    let dest_path = src_dir.join("registries.rs");

    if let Ok(existing) = fs::read_to_string(&dest_path)
        && existing == code
    {
        // Avoid rewriting it if it hasn't changed, so that we don't bump the timestamp and cause rebuilds
        return;
    }
    fs::write(dest_path, code).expect("Failed to write generated code");
}

// generate_spec_code generates the code to define the spec for a given variable.
fn generate_spec_code(spec: &MlxVariableSpec) -> String {
    match spec {
        MlxVariableSpec::Boolean => {
            "mlxconfig_variables::MlxVariableSpec::builder().boolean().build()".to_string()
        }
        MlxVariableSpec::Integer => {
            "mlxconfig_variables::MlxVariableSpec::builder().integer().build()".to_string()
        }
        MlxVariableSpec::String => {
            "mlxconfig_variables::MlxVariableSpec::builder().string().build()".to_string()
        }
        MlxVariableSpec::Binary => {
            "mlxconfig_variables::MlxVariableSpec::builder().binary().build()".to_string()
        }
        MlxVariableSpec::Bytes => {
            "mlxconfig_variables::MlxVariableSpec::builder().bytes().build()".to_string()
        }
        MlxVariableSpec::Array => {
            "mlxconfig_variables::MlxVariableSpec::builder().array().build()".to_string()
        }
        MlxVariableSpec::Enum { options } => {
            format!(
                "mlxconfig_variables::MlxVariableSpec::builder().enum_type().with_options(vec![{}]).build()",
                options
                    .iter()
                    .map(|opt| format!("{opt:?}.to_string()"))
                    .collect::<Vec<_>>()
                    .join(", ")
            )
        }
        MlxVariableSpec::Preset { max_preset } => {
            format!(
                "mlxconfig_variables::MlxVariableSpec::builder().preset().with_max_preset({max_preset}).build()",
            )
        }
        MlxVariableSpec::BooleanArray { size } => {
            format!(
                "mlxconfig_variables::MlxVariableSpec::builder().boolean_array().with_size({size}).build()",
            )
        }
        MlxVariableSpec::IntegerArray { size } => {
            format!(
                "mlxconfig_variables::MlxVariableSpec::builder().integer_array().with_size({size}).build()",
            )
        }
        MlxVariableSpec::EnumArray { options, size } => {
            format!(
                "mlxconfig_variables::MlxVariableSpec::builder().enum_array().with_options(vec![{}]).with_size({size}).build()",
                options
                    .iter()
                    .map(|opt| format!("{opt:?}.to_string()"))
                    .collect::<Vec<_>>()
                    .join(", ")
            )
        }
        MlxVariableSpec::BinaryArray { size } => {
            format!(
                "mlxconfig_variables::MlxVariableSpec::builder().binary_array().with_size({size}).build()",
            )
        }
        MlxVariableSpec::Opaque => {
            "mlxconfig_variables::MlxVariableSpec::builder().opaque().build()".to_string()
        }
    }
}
