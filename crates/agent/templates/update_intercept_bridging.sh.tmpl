#!/bin/bash

# Get the IPs currently on the bridge used for intercepting VMaaS traffic.
VF_BRIDGE_IPS=$(ip addr show dev {{ .VfInterceptBridgeName }} | grep -oP 'inet\s\K[\d.\/]+')

INCOMING_IPS=("{{ .VfInterceptBridgeIP }}/{{ .InterceptBridgePrefixLen }}" "{{ .SecondaryOverlayVtepIP }}/32")

# Find only the bridge IPs that need to be removed.
OLD_VF_BRIDGE_IPS=$(diff --old-line-format="%L" --unchanged-line-format="" --new-line-format="" \
    <(printf "%s\n" "${VF_BRIDGE_IPS[@]}" | sort) \
    <(printf "%s\n" "${INCOMING_IPS[@]}" | sort))


# Add the new internal routing IPs to the bridge if they need to be added.
if ! ip addr show {{ .VfInterceptBridgeName }} | grep {{ .VfInterceptBridgeIP }}/{{ .InterceptBridgePrefixLen }}; then
    ip addr add {{ .VfInterceptBridgeIP }}/{{ .InterceptBridgePrefixLen }} dev {{ .VfInterceptBridgeName }} || exit $?
fi

if ! ip addr show {{ .VfInterceptBridgeName }} | grep {{ .SecondaryOverlayVtepIP }}/32; then
    ip link set {{ .VfInterceptBridgeName }} up
    ip addr add {{ .SecondaryOverlayVtepIP }}/32 dev {{ .VfInterceptBridgeName }} || exit $?
    # This is how Catalyst learns the current local GENEVE VTEP IP.
    ovs-vsctl set Open_vSwitch . external_ids:ovn-encap-ip={{ .SecondaryOverlayVtepIP }} || exit $?
fi

# Now remove all the old IPs
# If something went wrong, we'll have exited and won't rip down the old IPs.
# The next cycle will put things in order if there are no errors.
for OLD_IP in "${OLD_VF_BRIDGE_IPS[@]}";do
    ip addr del $OLD_IP dev {{ .VfInterceptBridgeName }} || true
done;
